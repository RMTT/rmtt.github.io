---
title: MIT 6.s081(Operating System)
date: 2022-03-09
categories:
  - MIT 6.s081
  - Operating
tags:	
  - MIT Course
---

# MIT OS

> 课程地址: https://pdos.csail.mit.edu/6.S081/2020/schedule.html

在拖沓了许久之后, 终于OS给看完了. 总体来说质量很不错, 设计的lab都很好, 理清了不少底层的概念.

## 体验

+ 个人觉得OS课程的lab至关重要, 这也是MIT 6.s081做得非常好的点之一, 他们的lab确实做到了由浅入深.

+ 理论知识是围绕xv6来讲解, 同时后期开始讲解OS的一些经典paper, 这些可以让自己对OS的学术领域有一个基本的了解.

+ 然后lab大部分都是修改xv6, 因为xv6的代码非常简洁, 所以修改一般都比较轻松. 难的是OS里面一个很小的细节可能要debug很久.
+ 加深了对所谓并发的理解, 多线程的lab是设计一个用户空间的"线程调度器", 写完之后感觉对多线程/多进程的概念更清晰了, 虽然我觉得这里的多线程更像是协程.
+ 学习了一些经典的技术: copy-on-write, mmap, Read-Copy-Update
+ 看到meltdown的时候有点激动, 原作者是怎么想到这个做法的 (
+ 看了MIT 6.004之后惊叹数字电路上那么多精妙的设计, 现在看来OS里面也有很多精妙设计, 或者说是体系架构里面. 虽然MIT 6.004学习了页表, 但在OS里面可以看到页表的各种用法, 不得不佩服页表这个发明.
+ 知道了微内核和宏内核的区别

## 总结

+ 之前觉得一个CPU就是一个通用图灵机, 它的输入也是各种图灵机, 而其中之一就是OS, 而OS本身应该也是一个通用图灵机, 所以本质上OS是通过套娃提高了抽象层次, 简化了操作.

+ 现代OS的几个关键点应该是并发和安全. 对于并发, 常见的说法是多进程和多线程, 但实际上都是一回事, 只不过多线程是共享一个address space. 对于安全, 用页表来实现address space的隔离是个绝妙的idea, 虽然meltdown的出现吓到了不少人, 但这实际上也跟intel自己的micro-architecture实现有关, 好在现在已经可以在硬件层面修复了(不然还是得把用户空间和内核空间分开, 会拉低大概5%的性能).

+ 锁可以解决数据冲突, 但会降低并行性, 过度的使用等于没有并行.



